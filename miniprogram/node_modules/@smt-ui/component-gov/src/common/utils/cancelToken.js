/**
* @class CancelToken 中止token构造器
* @constructor exector 回调执行器
*/
export class CancelToken {
    constructor(exector) {
        if (typeof exector !== 'function') {
            return console.error('CancelToken 参数必须为函数');
        }
        let resolveProc;
        this.promise = new Promise(r => (resolveProc = r));
        exector(() => {
            if (this.reason) {
                return;
            }
            resolveProc(
                this.reason = {
                    code: 99998,
                    msg: 'request aborted by user'
                }
            );
        });
    }

    static source() {
        let cancel;
        const token = new CancelToken(c => (cancel = c));
        return {
            token, cancel
        };
    }

    throwIfRequested() {
        if (this.reason) {
            throw this.reason;
        }
    }
}

/**
 * genFetch 生成请求
 * @param {string} url 请求地址
 * @param {Object} options 配置
 * @return {Promise} then链
 */
export const genFetch = (url, options = {}) => {
    if (!options.method) {
        return console.error('必须指定method, 并且大写, 例如 GET、POST、DELETE、OPTION');
    }
    return new Promise((r, j) => {
        let xhr = swan.request({
            url,
            success: res => r(res),
            fail: err => j(err),
            ...options
        });

        if (options.cancelToken) {
            const token = options.cancelToken; // exector = c => cancel = c;
            token.promise.then(({code: errCode, msg: errMsg}) => {
                if (!xhr) {
                    return;
                }
                xhr.abort();
                j({errCode, errMsg});
                xhr = null;
            });
        }
    });
};
