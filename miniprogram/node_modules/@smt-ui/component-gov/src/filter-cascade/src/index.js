/**
 * @file filter-single-list组件
 * @author huangjing02
 */

/* globals Page, swan, getApp, getCurrentPages */
import {isIos} from '../../common/utils/index';
import {COLOR_TIPS_RED, COLOR_BLACK} from '../../common/style/color';


Component({

    externalClasses: [
        'gov-filter-cascade',
        'gov-column'
    ],

    properties: {
        // 筛选器ID
        options: {
            type: Array,
            value: []
        },

        // 筛选项数组，数组格式[{text:'名称', value: '值，string/Array.<string>', options: [{text: '', value: ''}, {text: '', value: ''}]}]
        optionKey: {
            type: String,
            value: '',
            observer(n) {
                this.setData({
                    currOptionKey: n || 'text'
                });
            }
        },

        value: {
            type: [String, Number, Array],
            value: ''
        },

        // 高亮时的文字和icon颜色
        activeColor: {
            type: String,
            value: COLOR_TIPS_RED
        },

        // 默认状态的文字颜色
        fontColor: {
            type: String,
            value: COLOR_BLACK
        }
    },

    data: {
        // 是否ios
        isIos,
        // 当前选中key
        currentOptions: [],
        currentValue: [],
        // 上一次值
        lastValue: [],
        rendered: false,
        targets: [],
        scrollTops: [],
        animate: false
    },

    created() {
        this.init(this.data.value);
    },

    attached() {
        this.setData('rendered', true);
    },

    methods: {
        // value后都取第一个
        genOptions(value = [], r = []) {
            let i = 0;
            const dfs = (options, value, r) => {
                const items = options.map(({children, ...item}) => item);
                r.push(items);
                const child = options[value[i] || 0] && options[value[i++] || 0].children;
                child && dfs(child, value, r);
                return r;
            };
            return dfs(this.data.options, value, r);
        },

        // 数组填零
        padEnd(arr, maxLen, char) {
            let n = maxLen - arr.length;
            while (n--) {
                arr.push(char);
            }
            return arr;
        },

        clkHdl(e) {
            const {index, idx, item} = e.currentTarget.dataset;
            this.clkInnerHdl(index, idx, item);
        },

        clkInnerHdl(index, idx, item, fillback) {
            const segEqual = (nums1, nums2, start, end) => { // 闭区间
                if (start > end) {
                    return false;
                }
                let len = end - start + 1;
                while (len--) {
                    if (nums1[len] !== nums2[len]) {
                        return false;
                    }
                }
                return true;
            };

            const currDup = [...this.data.currentValue];
            let val = this.data.currentValue;
            val.splice(index);
            val.push(idx);
            this.setData('currentValue', val);
            // this.data.currentValue.splice(index);
            // this.data.currentValue.push(idx);
            const last = this.genOptions(this.data.currentValue).length - 1;

            const tops = [...this.data.scrollTops];
            if (idx !== currDup[index]) {
                let j = index;
                while (j <= last) {
                    j++;
                    tops.splice(j, 1, 0);
                }
            }
            this.setData({
                animate: false
            }, () => {
                // swan.nextTick(() => {});
                this.setData({
                    scrollTops: [...tops],
                    animate: true
                });

                // 选值：保存上次值和位置
                if (index === last) {
                    this.data.currentValue.splice(index, 1, idx);
                    const {currentValue, currentOptions} = this.data;
                    this.setData('lastValue', [...currentValue]);
                    this.triggerEvent('change', {
                        type: 'cascade',
                        casCol: index,
                        casRow: idx,
                        casIndex: [...currentValue],
                        casValue: currentOptions.map((e, i) => e[currentValue[i]]),
                        fillback,
                        ...item
                    });
                }
                // 路径相等，则聚焦选中值
                else if (segEqual(this.data.currentValue, this.data.lastValue, 0, index)) {
                    let val = this.data.currentValue;
                    val.splice(0);
                    val.push(...this.data.lastValue);
                    this.setData('currentValue', val);
                    this.setData('currentOptions', this.genOptions(this.data.lastValue));
                    swan.nextTick(() => {
                        this.setData({
                            targets: this.data.lastValue.map(idx => ('item-idx-' + idx))
                        });
                    });
                }
                // 点击不同列表项，将剩余级置顶
                else {
                    this.padEnd(this.data.currentValue, last, 0);
                }
                this.setData('currentOptions', this.genOptions(this.data.currentValue));
            });

        },

        getIdxsByVal(val, r = []) {
            const dfs = (options, val) => options.some(({value, children}, idx) => {
                if (children && dfs(children, val, r)) {
                    return r.push(idx);
                }
                return value === val && r.push(idx);
            });
            dfs(this.data.options, val);
            return r.reverse();
        },

        /**
         * 获取一组values的位置 * 有更好方法，暂时保留
         * @param {Array} vals
         * @return {Promise<array>}
         */
        async getCurrValTop(vals) {
            const fn = (col, item) => new Promise(r => {
                const scrollView = item == null;
                const q = swan.createSelectorQuery().in(this);
                const selector = '.column-' + col + (scrollView ? '' : ' .item-idx-' + item);
                const method = scrollView ? 'scrollOffset' : 'boundingClientRect';
                const resultKey = scrollView ? 'scrollTop' : 'top';
                q.select(selector)[method](res => r(res[resultKey])).exec();
            });
            const cols = [];
            const items = [];
            for (const [idx, val] of vals.entries()) {
                cols.push(await fn(idx));
                items.push(await fn(idx, val));
            }
            return cols.map((scrollTop, idx) => scrollTop + items[idx]);
        },

        panelClk() {
            this.triggerEvent('panelclick');
        },

        /**
         * 还没显示，无法操作位置, 不要太快
         */
        expand() {
            if (this.data.rendered) {
                setTimeout(() => {
                    this.setData('targets', this.data.lastValue.map(idx => 'item-idx-' + idx));
                }, 100);
            }
        },

        cancel() {
            this.data.currentValue.splice(0);
            this.data.currentValue.push(...this.data.lastValue);
            this.setData('currentOptions', this.genOptions([...this.data.lastValue]));
        },

        init(value, fillback) {
            if (!Array.isArray(value)) { // 接口有的value是string，有的是number
                value = this.getIdxsByVal(value);
            }
            const normVal = JSON.stringify(value);
            const normCurrVal = JSON.stringify(this.data.currentValue);
            if (fillback && normVal === normCurrVal) { // 回填相同的值不触发
                return;
            }

            // 初始化选项
            const currentOptions = this.genOptions(value);
            this.setData('currentOptions', currentOptions);

            // 多列value时，默认选第一项
            if (value.length === 0 && currentOptions.length > 1) {
                value = Array.from({length: currentOptions.length - 1}, _ => 0);
            }
            this.setData({
                currentValue: value,
                lastValue: [...value]
            });
            if (!this.data.rendered) { // 初始化不触发选中
                // 初始化也要自动聚焦
                this.setData({
                    scrollTops: new Array(value.length).fill(0)
                }, () => {
                    this.setData('targets', value.map(idx => 'item-idx-' + idx));
                });
                // swan.nextTick(() => {});
                return;
            }
            swan.nextTick(() => {
                const last = value.length - 1;
                const lastVal = value[last];
                this.clkInnerHdl(last, lastVal, currentOptions[last][lastVal], fillback);
            });
        },

        // 级联筛选回填：value回填string，返回object
        // 缺点：无法使用v-model，表单需转换； 优点：无需开发者转换，适用于非表单场景
        setValue(value) {
            this.init(value, true);
        }
    }
});
