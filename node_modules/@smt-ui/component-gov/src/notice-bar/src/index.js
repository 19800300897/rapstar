/**
 * @file notice-bar
 * @author LipengJia (jialipeng@baidu.com)
 * @date 2019-12-19
 */

 /* global swan */

import {COLOR_ORANGE} from '../../common/style/color';

Component({ // eslint-disable-line
    externalClasses: ['ext-cls', 'text-cls'],

    properties: {
        text: {
            type: String,
            value: '通知栏:notice-bar',
            observer() {
                this.init();
            }
        },

        bgColor: {
            type: String,
            value: ''
        },

        textColor: {
            type: String,
            value: ''
        },

        icon: {
            type: Boolean,
            value: true
        },

        iconName: {
            type: String,
            value: 'close'
        },

        iconColor: {
            type: [Array, String],
            value: COLOR_ORANGE
        },

        scroll: {
            type: Boolean,
            value: true
        },

        delay: {
            type: Number,
            value: 1
        },

        // 速度：px/s; 默认50
        speed: {
            type: Number,
            value: 50
        }
    },

    data: {
        // 第二轮进入循环
        infinite: false,

        // 容器宽度 判断是否超出开启滚动
        containerWidth: 0,

        // 文本宽度，计算速度
        textWidth: 0,

        // 动画配置
        animationData: null,

        show: true
    },

    methods: {
        getWidths(selector) {
            return new Promise(r =>
                this.createSelectorQuery().in(this).select(selector)
                .boundingClientRect(({width}) => r(width)).exec()
            );
        },
        /**
         * 初始化函数
         * 通过字数获取宽度不准，因为
         */
        async init() {
            // 不开启滚动，则退出
            if (!this.data.scroll) {
                return;
            }
            const [containerWidth, textWidth] = await [
                await this.getWidths('.notice-bar .text-container'),
                await this.getWidths('.notice-bar .text-container .text')
            ];
            const duration = +(textWidth / this.data.speed * 1000).toFixed(2);
            this.setData({textWidth, containerWidth}, () => {
                if (textWidth > containerWidth) {
                    setTimeout(() => this.genAnimate(duration, textWidth), this.data.delay * 1000);
                }
            });
        },

        /**
         * 生成动画
         * @param {number} duration 动画时长
         */
        genAnimate(duration, distance) {
            // 须先复位
            const animation = swan.createAnimation({
                duration: 0
            });
            animation.translate3d(0, 0, 0).step();
            this.setData({
                animationData: animation.export()
            }, () => {
                const animation = swan.createAnimation({
                    duration
                });
                animation.translate3d(0, 0, 0).translateX(`-${distance}px`, 0, 0).step();
                this.setData({
                    animationData: animation.export()
                });
            });
        },

        aniEndHdl() {
            const {textWidth, speed, containerWidth, infinite} = this.data;
            const duration = +((textWidth + containerWidth) / speed * 1000).toFixed(2);
            const fn = () => this.genAnimate(duration, textWidth + containerWidth);
            if (!infinite) {
                this.setData({infinite: true}, fn);
            }
            else {
                fn();
            }
        },

        closeHdl() {
            this.setData({
                show: false,
                animationData: null
            });
            this.triggerEvent('close');
        }
    },

    created() {
        this.init();
    }
});
