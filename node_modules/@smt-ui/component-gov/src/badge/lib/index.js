"use strict";

/**
 * @file 自定义徽标数
 * @author swan
 */
var prefixCls = 'badge';
var statusArr = ['success', 'processing', 'default', 'error', 'warning'];
var typeArr = ['success', 'primary', 'normal', 'error', 'warning', 'info'];
Component({
  externalClasses: ['gov-text', 'gov-dot-class'],
  properties: {
    count: {
      type: Number,
      value: '',
      observer: function observer(newVal, oldVal) {
        this.computedBadge();
        this.computedFinalCount();
        this.computedHasCount();
      }
    },
    dot: {
      type: Boolean,
      value: false,
      observer: function observer(newVal, oldVal) {
        this.computedBadge();
      }
    },
    overflowCount: {
      type: [Number, String],
      value: 9999,
      observer: function observer(newVal, oldVal) {
        this.computedFinalCount();
      }
    },
    showZero: {
      type: Boolean,
      value: false,
      observer: function observer(newVal, oldVal) {
        this.computedBadge();
        this.computedHasCount();
      }
    },
    text: {
      type: String,
      value: '',
      observer: function observer(newVal, oldVal) {
        this.computedBadge();
        this.computedFinalCount();
        this.computedHasCount();
      }
    },
    status: {
      type: String,
      value: '',
      observer: function observer(newVal, oldVal) {
        this.computedStatus();
        this.computedStatusClasses();
      }
    },
    type: {
      type: String,
      value: '',
      observer: function observer(newVal, oldVal) {
        this.computedType();
        this.computedCountClasses();
      }
    },
    offset: {
      type: Array,
      observer: function observer(newVal, oldVal) {
        this.computedStyle();
      }
    },
    alone: {
      type: Boolean,
      value: false,
      observer: function observer(newVal, oldVal) {
        this.computedCountClasses();
      }
    }
  },
  data: {
    status: false,
    hasType: false,
    classes: "".concat(prefixCls),
    dotClasses: "".concat(prefixCls, "-dot"),
    countClasses: [],
    statusClasses: [],
    styles: {},
    finalCount: 0,
    badge: false,
    hasCount: false
  },
  lifetimes: {
    attached: function attached() {
      // 计算badge
      this.computedBadge(); // 计算status

      this.computedStatus(); // 计算样式

      this.computedType(); // 计算类

      this.computedClasses(); // 计算点的类

      this.computedDotClasses(); // 数字类型的样式

      this.computedCountClasses(); // 状态类

      this.computedStatusClasses(); // 坐标位置调整

      this.computedStyle(); // 最终显示的数字/文案

      this.computedFinalCount(); // 是否有count

      this.computedHasCount();
    }
  },
  methods: {
    computedBadge: function computedBadge() {
      var status = false;

      if (this.data.count) {
        status = !(parseInt(this.data.count, 10) === 0);
      }

      if (this.data.dot) {
        status = true;

        if (this.data.count !== null) {
          if (parseInt(this.data.count, 10) === 0) {
            status = false;
          }
        }
      }

      if (this.data.text !== '') {
        status = true;
      }

      this.setData({
        badge: status || this.data.showZero
      });
    },
    computedStatus: function computedStatus() {
      var flag = false;
      flag = statusArr.includes(this.data.status);
      this.setData({
        status: flag
      });
      return flag;
    },
    computedType: function computedType() {
      var flag = false;
      flag = typeArr.includes(this.data.type);
      this.setData({
        hasType: flag
      });
      return flag;
    },
    computedClasses: function computedClasses() {
      var classes = "".concat(prefixCls);
      this.setData({
        classes: classes
      });
    },
    computedDotClasses: function computedDotClasses() {
      var dotClasses = "".concat(prefixCls, "-dot");
      this.setData({
        dotClasses: dotClasses
      });
    },
    computedCountClasses: function computedCountClasses() {
      var countClasses = ["".concat(prefixCls, "-count")];
      var type = !!this.computedType();

      if (!!this.data.alone) {
        countClasses.push("".concat(prefixCls, "-count-alone"));
      }

      if (!!type) {
        countClasses.push("".concat(prefixCls, "-count-").concat(this.data.type));
      }

      this.setData({
        countClasses: countClasses
      });
    },
    computedStatusClasses: function computedStatusClasses() {
      var statusClasses = ["".concat(prefixCls, "-status-dot")];

      if (!!this.data.status) {
        statusClasses.push("".concat(prefixCls, "-status-").concat(this.data.status));
      }

      this.setData({
        statusClasses: statusClasses
      });
    },
    computedStyle: function computedStyle() {
      var style = {}; // 设置状态点的位置偏移，格式为 [x, y]

      if (this.data.offset && this.data.offset.length === 2) {
        style['top'] = "".concat(this.data.offset[0], "px");
        style['left'] = "".concat(this.data.offset[1], "px");
      }

      this.setData({
        styles: style
      });
    },
    computedFinalCount: function computedFinalCount() {
      var finalCount = 0;

      if (this.data.text !== '') {
        finalCount = this.data.text.slice(0, 3);
      } else if (parseInt(this.data.count, 10) >= parseInt(this.data.overflowCount, 10)) {
        finalCount = "".concat(this.data.overflowCount, "+");
      } else {
        finalCount = this.data.count || 0;
      }

      this.setData({
        finalCount: finalCount
      });
    },
    computedHasCount: function computedHasCount() {
      var hasCount = false;

      if (this.data.count || this.data.text !== '') {
        hasCount = true;
      } else if (this.data.showZero && parseInt(this.data.count, 10) === 0) {
        hasCount = true;
      } else {
        hasCount = false;
      }

      this.setData({
        hasCount: hasCount
      });
    }
  }
});